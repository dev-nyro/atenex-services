name: CI/CD Pipeline Docker -> Manifest Update (All Services - Selective Build)

on:
  push:
    branches: [ "develop" ]

env:
  REGISTRY: ghcr.io
  MANIFEST_REPO_OWNER: dev-nyro
  MANIFEST_REPO_NAME: manifests-nyro
  MANIFEST_REPO_BRANCH: develop

  INGEST_SERVICE_DIR: ingest-service
  INGEST_IMAGE_NAME: ghcr.io/dev-nyro/ingest-service
  QUERY_SERVICE_DIR: query-service
  QUERY_IMAGE_NAME: ghcr.io/dev-nyro/query-service
  GATEWAY_SERVICE_DIR: api-gateway
  GATEWAY_IMAGE_NAME: ghcr.io/dev-nyro/api-gateway
  EMBEDDING_SERVICE_DIR: embedding-service
  EMBEDDING_IMAGE_NAME: ghcr.io/dev-nyro/embedding-service
  DOCPROC_SERVICE_DIR: docproc-service
  DOCPROC_IMAGE_NAME: ghcr.io/dev-nyro/docproc-service
  RERANKER_SERVICE_DIR: reranker-service
  RERANKER_IMAGE_NAME: ghcr.io/dev-nyro/reranker-service

jobs:
  build-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      pull-requests: read
    outputs:
      ingest_built: ${{ steps.build_ingest.outputs.digest != '' && steps.build_ingest.outcome == 'success' }}
      query_built: ${{ steps.build_query.outputs.digest != '' && steps.build_query.outcome == 'success' }}
      gateway_built: ${{ steps.build_gateway.outputs.digest != '' && steps.build_gateway.outcome == 'success' }}
      embedding_built: ${{ steps.build_embedding.outputs.digest != '' && steps.build_embedding.outcome == 'success' }}
      docproc_built: ${{ steps.build_docproc.outputs.digest != '' && steps.build_docproc.outcome == 'success' }}
      reranker_built: ${{ steps.build_reranker.outputs.digest != '' && steps.build_reranker.outcome == 'success' }}
      image_tag: ${{ steps.image_tag_common.outputs.image_tag }}

    steps:
      - name: Checkout Application Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug Before/After SHAs
        run: |
          echo "github.event.before: ${{ github.event.before }}"
          echo "github.sha: ${{ github.sha }}"

      - name: Get changed files if commits differ or new branch
        id: changed_files_action
        if: github.event.before == '0000000000000000000000000000000000000000' || github.event.before != github.sha
        uses: tj-actions/changed-files@v44
        with:
          sha: ${{ github.event.before }}
          files_yaml: |
            ingest:
              - '${{ env.INGEST_SERVICE_DIR }}/**'
            query:
              - '${{ env.QUERY_SERVICE_DIR }}/**'
            gateway:
              - '${{ env.GATEWAY_SERVICE_DIR }}/**'
            embedding:
              - '${{ env.EMBEDDING_SERVICE_DIR }}/**'
            docproc:
              - '${{ env.DOCPROC_SERVICE_DIR }}/**'
            reranker:
              - '${{ env.RERANKER_SERVICE_DIR }}/**'

      - name: Set changed files outputs
        id: changed_files
        shell: bash
        run: |
          SHOULD_RUN_TJ_ACTION=false
          if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" || "${{ github.event.before }}" != "${{ github.sha }}" ]]; then
            SHOULD_RUN_TJ_ACTION=true
          fi

          if [[ "$SHOULD_RUN_TJ_ACTION" == "true" ]]; then
            echo "Using outputs from tj-actions/changed-files"
            echo "ingest_any_changed=${{ steps.changed_files_action.outputs.ingest_any_changed || 'false' }}" >> $GITHUB_OUTPUT
            echo "query_any_changed=${{ steps.changed_files_action.outputs.query_any_changed || 'false' }}" >> $GITHUB_OUTPUT
            echo "gateway_any_changed=${{ steps.changed_files_action.outputs.gateway_any_changed || 'false' }}" >> $GITHUB_OUTPUT
            echo "embedding_any_changed=${{ steps.changed_files_action.outputs.embedding_any_changed || 'false' }}" >> $GITHUB_OUTPUT
            echo "docproc_any_changed=${{ steps.changed_files_action.outputs.docproc_any_changed || 'false' }}" >> $GITHUB_OUTPUT
            echo "reranker_any_changed=${{ steps.changed_files_action.outputs.reranker_any_changed || 'false' }}" >> $GITHUB_OUTPUT
          else
            echo "No new commits in this push. Setting all changed flags to false."
            echo "ingest_any_changed=false" >> $GITHUB_OUTPUT
            echo "query_any_changed=false" >> $GITHUB_OUTPUT
            echo "gateway_any_changed=false" >> $GITHUB_OUTPUT
            echo "embedding_any_changed=false" >> $GITHUB_OUTPUT
            echo "docproc_any_changed=false" >> $GITHUB_OUTPUT
            echo "reranker_any_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true' || steps.changed_files.outputs.embedding_any_changed == 'true' || steps.changed_files.outputs.docproc_any_changed == 'true' || steps.changed_files.outputs.reranker_any_changed == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true' || steps.changed_files.outputs.embedding_any_changed == 'true' || steps.changed_files.outputs.docproc_any_changed == 'true' || steps.changed_files.outputs.reranker_any_changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Common Image Tag
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true' || steps.changed_files.outputs.embedding_any_changed == 'true' || steps.changed_files.outputs.docproc_any_changed == 'true' || steps.changed_files.outputs.reranker_any_changed == 'true'
        id: image_tag_common
        run: |
          TAG="${{ github.ref_name }}-$(echo $GITHUB_SHA | cut -c1-7)"
          TAG=$(echo $TAG | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/^[.-]*//;s/[.-]*$//')
          TAG=${TAG::128}
          echo "Generated Common Tag: $TAG"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # ... (Pasos de build para cada servicio, como los tenías) ...
      - name: Build and push Ingest Service Docker image
        id: build_ingest
        if: steps.changed_files.outputs.ingest_any_changed == 'true'
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.INGEST_SERVICE_DIR }}
          file: ./${{ env.INGEST_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.INGEST_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Build and push Query Service Docker image
        id: build_query
        if: steps.changed_files.outputs.query_any_changed == 'true'
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.QUERY_SERVICE_DIR }}
          file: ./${{ env.QUERY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.QUERY_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Build and push API Gateway Docker image
        id: build_gateway
        if: steps.changed_files.outputs.gateway_any_changed == 'true'
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.GATEWAY_SERVICE_DIR }}
          file: ./${{ env.GATEWAY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.GATEWAY_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Build and push Embedding Service Docker image
        id: build_embedding
        if: steps.changed_files.outputs.embedding_any_changed == 'true'
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.EMBEDDING_SERVICE_DIR }}
          file: ./${{ env.EMBEDDING_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.EMBEDDING_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Build and push DocProc Service Docker image
        id: build_docproc
        if: steps.changed_files.outputs.docproc_any_changed == 'true'
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.DOCPROC_SERVICE_DIR }}
          file: ./${{ env.DOCPROC_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.DOCPROC_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Build and push Reranker Service Docker image
        id: build_reranker
        if: steps.changed_files.outputs.reranker_any_changed == 'true'
        continue-on-error: true # Importante: revisa los logs de este paso si falla.
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.RERANKER_SERVICE_DIR }} # Asegúrate que esta es la ruta correcta al Dockerfile
          file: ./${{ env.RERANKER_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.RERANKER_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry

      - name: Debug Build Outputs and Job Outputs Evaluation
        if: always()
        run: |
          # ... (como lo tenías, es útil para depurar) ...
          echo "::group::Debug Information from build-push job"
          echo "Event Name: ${{ github.event_name }}"
          echo "Commit SHA before push (github.event.before): ${{ github.event.before }}"
          echo "Current Commit SHA (github.sha): ${{ github.sha }}"
          echo "Common Image Tag Generated (steps.image_tag_common.outputs.image_tag): ${{ steps.image_tag_common.outputs.image_tag }}"
          echo "--- Changed Files Outputs (from step 'changed_files') ---"
          echo "Ingest any_changed: ${{ steps.changed_files.outputs.ingest_any_changed }}"
          echo "Query any_changed: ${{ steps.changed_files.outputs.query_any_changed }}"
          echo "Gateway any_changed: ${{ steps.changed_files.outputs.gateway_any_changed }}"
          echo "Embedding any_changed: ${{ steps.changed_files.outputs.embedding_any_changed }}"
          echo "DocProc any_changed: ${{ steps.changed_files.outputs.docproc_any_changed }}"
          echo "Reranker any_changed: ${{ steps.changed_files.outputs.reranker_any_changed }}"
          echo "--- Individual Build Step Details ---"
          echo "build_ingest outcome: ${{ steps.build_ingest.outcome }}, digest: '${{ steps.build_ingest.outputs.digest }}'"
          echo "build_query outcome: ${{ steps.build_query.outcome }}, digest: '${{ steps.build_query.outputs.digest }}'"
          echo "build_gateway outcome: ${{ steps.build_gateway.outcome }}, digest: '${{ steps.build_gateway.outputs.digest }}'"
          echo "build_embedding outcome: ${{ steps.build_embedding.outcome }}, digest: '${{ steps.build_embedding.outputs.digest }}'"
          echo "build_docproc outcome: ${{ steps.build_docproc.outcome }}, digest: '${{ steps.build_docproc.outputs.digest }}'"
          echo "build_reranker outcome: ${{ steps.build_reranker.outcome }}, digest: '${{ steps.build_reranker.outputs.digest }}'"
          echo "--- Job Outputs Evaluation (as they would be for 'needs' context) ---"
          echo "Output ingest_built: ${{ (steps.build_ingest.outputs.digest != '' && steps.build_ingest.outcome == 'success') }}"
          echo "Output query_built: ${{ (steps.build_query.outputs.digest != '' && steps.build_query.outcome == 'success') }}"
          echo "Output gateway_built: ${{ (steps.build_gateway.outputs.digest != '' && steps.build_gateway.outcome == 'success') }}"
          echo "Output embedding_built: ${{ (steps.build_embedding.outputs.digest != '' && steps.build_embedding.outcome == 'success') }}"
          echo "Output docproc_built: ${{ (steps.build_docproc.outputs.digest != '' && steps.build_docproc.outcome == 'success') }}"
          echo "Output reranker_built: ${{ (steps.build_reranker.outputs.digest != '' && steps.build_reranker.outcome == 'success') }}"
          echo "::endgroup::"

  update-manifests:
    needs: build-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (needs.build-push.outputs.ingest_built == 'true' || needs.build-push.outputs.query_built == 'true' || needs.build-push.outputs.gateway_built == 'true' || needs.build-push.outputs.embedding_built == 'true' || needs.build-push.outputs.docproc_built == 'true' || needs.build-push.outputs.reranker_built == 'true')

    steps:
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Debug Update Manifests Job Trigger
        # ... (como lo tenías) ...
        run: |
          echo "::group::Debug Information for update-manifests job trigger"
          echo "Job triggered because at least one service was built."
          echo "needs.build-push.outputs.ingest_built: ${{ needs.build-push.outputs.ingest_built }}"
          echo "needs.build-push.outputs.query_built: ${{ needs.build-push.outputs.query_built }}"
          echo "needs.build-push.outputs.gateway_built: ${{ needs.build-push.outputs.gateway_built }}"
          echo "needs.build-push.outputs.embedding_built: ${{ needs.build-push.outputs.embedding_built }}"
          echo "needs.build-push.outputs.docproc_built: ${{ needs.build-push.outputs.docproc_built }}"
          echo "needs.build-push.outputs.reranker_built: ${{ needs.build-push.outputs.reranker_built }}"
          echo "needs.build-push.outputs.image_tag: ${{ needs.build-push.outputs.image_tag }}"
          echo "::endgroup::"

      - name: Checkout Manifests Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MANIFEST_REPO_OWNER }}/${{ env.MANIFEST_REPO_NAME }}
          ref: ${{ env.MANIFEST_REPO_BRANCH }}
          token: ${{ secrets.MANIFEST_PAT }}
          path: manifests-repo

      - name: Update Manifest Files Conditionally
        id: update_manifest_files
        env:
          # ... (variables de entorno como las tenías) ...
          INGEST_BUILT: ${{ needs.build-push.outputs.ingest_built }}
          QUERY_BUILT: ${{ needs.build-push.outputs.query_built }}
          GATEWAY_BUILT: ${{ needs.build-push.outputs.gateway_built }}
          EMBEDDING_BUILT: ${{ needs.build-push.outputs.embedding_built }}
          DOCPROC_BUILT: ${{ needs.build-push.outputs.docproc_built }}
          RERANKER_BUILT: ${{ needs.build-push.outputs.reranker_built }}
          COMMON_TAG: ${{ needs.build-push.outputs.image_tag }}
          INGEST_MANIFEST_PATH_API_REL: ${{ env.INGEST_SERVICE_DIR }}/deployment-api.yaml
          INGEST_MANIFEST_PATH_WORKER_REL: ${{ env.INGEST_SERVICE_DIR }}/deployment-worker.yaml
          QUERY_MANIFEST_PATH_REL: ${{ env.QUERY_SERVICE_DIR }}/deployment.yaml
          GATEWAY_MANIFEST_PATH_REL: ${{ env.GATEWAY_SERVICE_DIR }}/deployment.yaml
          EMBEDDING_MANIFEST_PATH_REL: ${{ env.EMBEDDING_SERVICE_DIR }}/deployment.yaml
          DOCPROC_MANIFEST_PATH_REL: ${{ env.DOCPROC_SERVICE_DIR }}/deployment.yaml
          RERANKER_MANIFEST_PATH_REL: ${{ env.RERANKER_SERVICE_DIR }}/deployment.yaml
          # Pasar nombres de imagen base para la expansión indirecta
          INGEST_IMAGE_NAME_BASE: ${{ env.INGEST_IMAGE_NAME }}
          QUERY_IMAGE_NAME_BASE: ${{ env.QUERY_IMAGE_NAME }}
          GATEWAY_IMAGE_NAME_BASE: ${{ env.GATEWAY_IMAGE_NAME }}
          EMBEDDING_IMAGE_NAME_BASE: ${{ env.EMBEDDING_IMAGE_NAME }}
          DOCPROC_IMAGE_NAME_BASE: ${{ env.DOCPROC_IMAGE_NAME }}
          RERANKER_IMAGE_NAME_BASE: ${{ env.RERANKER_IMAGE_NAME }}
        run: |
          echo "::group::Updating Manifest Files Conditionally"
          cd manifests-repo
          echo "Current directory: $(pwd)"
          echo "Using COMMON_TAG: $COMMON_TAG for manifest updates."

          if [ -z "$COMMON_TAG" ]; then
            echo "::error::COMMON_TAG is empty in update_manifest_files step. Aborting."
            exit 1
          fi

          update_single_manifest() {
            local SERVICE_DISPLAY_NAME="$1" # e.g., "Reranker Service"
            local BUILT_FLAG="$2"
            local IMAGE_BASE_NAME_ENV_VAR_SUFFIX="$3" # e.g., RERANKER (para construir RERANKER_IMAGE_NAME_BASE)
            local MANIFEST_PATH_REL="$4"
            
            # Construir el nombre de la variable de entorno que contiene el nombre base de la imagen
            local IMAGE_BASE_NAME_VAR_NAME="${IMAGE_BASE_NAME_ENV_VAR_SUFFIX}_IMAGE_NAME_BASE"
            local IMAGE_BASE_NAME="${!IMAGE_BASE_NAME_VAR_NAME}" # Expansión indirecta

            # Derivar el nombre del contenedor k8s esperado (ej: "reranker-service")
            local K8S_CONTAINER_NAME
            if [[ "$SERVICE_DISPLAY_NAME" == "Ingest API" || "$SERVICE_DISPLAY_NAME" == "Ingest Worker" ]]; then
                # Asume que ambos manifiestos de ingest usan el mismo nombre de contenedor 'ingest-service'
                # O ajusta si tienen nombres de contenedor diferentes (ej: 'ingest-api', 'ingest-worker')
                K8S_CONTAINER_NAME="ingest-service" 
            else
                # Convierte "Query Service" a "query-service", "Reranker Service" a "reranker-service"
                K8S_CONTAINER_NAME=$(echo "$SERVICE_DISPLAY_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')
            fi
            echo "Derived K8S_CONTAINER_NAME: $K8S_CONTAINER_NAME for $SERVICE_DISPLAY_NAME"


            if [ "$BUILT_FLAG" = "true" ]; then
              TARGET_IMAGE="${IMAGE_BASE_NAME}:${COMMON_TAG}"
              echo "Attempting to update $SERVICE_DISPLAY_NAME (container: $K8S_CONTAINER_NAME) image to: $TARGET_IMAGE in $MANIFEST_PATH_REL"
              if [ -f "$MANIFEST_PATH_REL" ]; then
                # Intentar actualizar usando el nombre del contenedor derivado
                if yq -i '(.spec.template.spec.containers[] | select(.name == "'"$K8S_CONTAINER_NAME"'") ).image = "'"$TARGET_IMAGE"'"' "$MANIFEST_PATH_REL"; then
                  echo "Successfully updated image for container '$K8S_CONTAINER_NAME' in $MANIFEST_PATH_REL"
                else
                  # Fallback si el nombre del contenedor no coincide o yq falla con ese selector
                  echo "::warning::Could not update image for container '$K8S_CONTAINER_NAME' by name in $MANIFEST_PATH_REL. Attempting to update the first container as fallback."
                  if yq -i '(.spec.template.spec.containers[0].image) = "'"$TARGET_IMAGE"'"' "$MANIFEST_PATH_REL"; then
                     echo "Successfully updated image for the first container in $MANIFEST_PATH_REL as fallback."
                  else
                     echo "::error::Failed to update image in $MANIFEST_PATH_REL for $SERVICE_DISPLAY_NAME using yq (both by name and fallback)."
                  fi
                fi
              else
                echo "::error::$SERVICE_DISPLAY_NAME manifest file '$MANIFEST_PATH_REL' not found!"
              fi
            else
              echo "Skipping $SERVICE_DISPLAY_NAME manifest update (BUILT_FLAG is '$BUILT_FLAG', not 'true')."
            fi
          }
          
          # Pasar un sufijo para construir el nombre de la variable IMAGE_BASE_NAME_VAR_NAME
          update_single_manifest "Ingest API" "$INGEST_BUILT" "INGEST" "$INGEST_MANIFEST_PATH_API_REL"
          if [ -n "$INGEST_MANIFEST_PATH_WORKER_REL" ]; then
            if [ -f "$INGEST_MANIFEST_PATH_WORKER_REL" ]; then
              update_single_manifest "Ingest Worker" "$INGEST_BUILT" "INGEST" "$INGEST_MANIFEST_PATH_WORKER_REL"
            else
              echo "::warning::Ingest Worker manifest path defined ($INGEST_MANIFEST_PATH_WORKER_REL) but file not found. Skipping."
            fi
          fi
          update_single_manifest "Query Service" "$QUERY_BUILT" "QUERY" "$QUERY_MANIFEST_PATH_REL"
          update_single_manifest "API Gateway" "$GATEWAY_BUILT" "GATEWAY" "$GATEWAY_MANIFEST_PATH_REL"
          update_single_manifest "Embedding Service" "$EMBEDDING_BUILT" "EMBEDDING" "$EMBEDDING_MANIFEST_PATH_REL"
          update_single_manifest "DocProc Service" "$DOCPROC_BUILT" "DOCPROC" "$DOCPROC_MANIFEST_PATH_REL"
          update_single_manifest "Reranker Service" "$RERANKER_BUILT" "RERANKER" "$RERANKER_MANIFEST_PATH_REL"
          
          echo "--- Checking Git Status Before Commit ---"
          git status
          
          git add .
          if git diff --staged --quiet; then
            echo "manifest_actually_changed=false" >> $GITHUB_OUTPUT
            echo "No actual manifest changes were detected by git after yq commands."
          else
            echo "manifest_actually_changed=true" >> $GITHUB_OUTPUT
            echo "Manifest changes detected by git after yq commands."
          fi
          echo "::endgroup::"

      - name: Commit and Push Manifest Changes
        if: steps.update_manifest_files.outputs.manifest_actually_changed == 'true'
        env:
          IMAGE_TAG_FOR_COMMIT: ${{ needs.build-push.outputs.image_tag }}
        run: |
          # ... (como lo tenías) ...
          echo "::group::Committing and Pushing Manifest Changes"
          cd manifests-repo
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          echo "Manifest changes detected. Committing..."
          COMMIT_MSG="Update service image(s) to tag $IMAGE_TAG_FOR_COMMIT [CI]"
          git commit -m "$COMMIT_MSG"
          if git push origin ${{ env.MANIFEST_REPO_BRANCH }}; then
              echo "Push successful."
          else
              echo "::error::Push failed. Check PAT permissions and branch protection rules."
              exit 1
          fi
          echo "::endgroup::"