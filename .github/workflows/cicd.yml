# .github/workflows/CICD.yml
name: CI/CD Pipeline Docker -> Manifest Update (Selective Build)

on:
  push:
    branches: [ "develop" ] # Ejecutar solo en pushes a la rama develop

env:
  # --- Configuración General ---
  REGISTRY: ghcr.io # Registro de contenedores
  MANIFEST_REPO_OWNER: dev-nyro # Dueño del repo de manifests
  MANIFEST_REPO_NAME: manifests-nyro # Nombre del repo de manifests
  MANIFEST_REPO_BRANCH: develop # Rama del repo de manifests a actualizar

  # --- Configuración Específica de Servicios ---
  # IMPORTANTE: Estos deben coincidir con los directorios en tu repo de código fuente
  INGEST_SERVICE_DIR: ingest-service
  QUERY_SERVICE_DIR: query-service
  GATEWAY_SERVICE_DIR: api-gateway

  # Nombres base de las imágenes (sin el tag)
  INGEST_IMAGE_NAME_BASE: ghcr.io/dev-nyro/ingest-service
  QUERY_IMAGE_NAME_BASE: ghcr.io/dev-nyro/query-service
  GATEWAY_IMAGE_NAME_BASE: ghcr.io/dev-nyro/api-gateway

  # --- Rutas RELATIVAS a los archivos de deployment DENTRO del repo de manifests ---
  # ¡¡¡CRÍTICO!!! Asegúrate que estas rutas sean EXACTAS a la estructura de tu repo 'manifests-nyro'
  INGEST_API_MANIFEST_PATH_REL: ingest-service/deployment-api.yaml # Ejemplo: si está en ingest-service/deployment-api.yaml
  INGEST_WORKER_MANIFEST_PATH_REL: ingest-service/deployment-worker.yaml # Ejemplo: si tienes un worker separado
  QUERY_MANIFEST_PATH_REL: query-service/deployment.yaml # Ejemplo: si está en query-service/deployment.yaml
  GATEWAY_MANIFEST_PATH_REL: api-gateway/deployment.yaml # Ejemplo: si está en api-gateway/deployment.yaml

jobs:
  # Job 1: Construir imágenes Docker si hay cambios y empujarlas a GHCR
  build-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Necesario para checkout del código fuente
      packages: write # Necesario para push a GHCR

    outputs:
      # Outputs para indicar qué imágenes se construyeron y cuál es el tag común
      ingest_built: ${{ steps.build_ingest.outputs.digest != '' }}
      query_built: ${{ steps.build_query.outputs.digest != '' }}
      gateway_built: ${{ steps.build_gateway.outputs.digest != '' }}
      image_tag: ${{ steps.image_tag_common.outputs.image_tag }} # Pasar el tag generado

    steps:
      # 1. Checkout del código fuente de la aplicación
      - name: Checkout Application Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para detectar cambios correctamente

      # 2. Detectar archivos modificados en los directorios de los servicios
      - name: Get changed files
        id: changed_files
        uses: tj-actions/changed-files@v44
        with:
          files_yaml: |
            ingest:
              - '${{ env.INGEST_SERVICE_DIR }}/**'
            query:
              - '${{ env.QUERY_SERVICE_DIR }}/**'
            gateway:
              - '${{ env.GATEWAY_SERVICE_DIR }}/**'

      # 3. Configurar Docker Buildx (solo si algún servicio cambió)
      - name: Set up Docker Buildx
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/setup-buildx-action@v3

      # 4. Login a GHCR (solo si algún servicio cambió)
      - name: Log in to GitHub Container Registry
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }} # Usuario que ejecuta la action
          password: ${{ secrets.GITHUB_TOKEN }} # Token temporal de la action

      # 5. Generar etiqueta común para las imágenes (solo si algún servicio cambió)
      - name: Generate Common Image Tag
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        id: image_tag_common
        run: |
          # Tag: nombre-rama-shortSHA (ej: develop-a1b2c3d)
          TAG="${{ github.ref_name }}-$(echo $GITHUB_SHA | cut -c1-7)"
          # Sanitize tag: reemplazar caracteres inválidos, quitar guiones al inicio/final, limitar longitud
          TAG=$(echo "$TAG" | sed -e 's/[^a-zA-Z0-9.-]/-/g' -e 's/^[.-]*//' -e 's/[.-]*$//')
          TAG=${TAG::128} # Límite de 128 caracteres para tags Docker
          echo "Generated Common Tag: $TAG"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # 6. Construir y Empujar Imagen - Ingest Service (solo si cambió)
      - name: Build and push Ingest Service Docker image
        id: build_ingest
        if: steps.changed_files.outputs.ingest_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.INGEST_SERVICE_DIR }} # Directorio del Dockerfile
          file: ./${{ env.INGEST_SERVICE_DIR }}/Dockerfile # Ruta al Dockerfile
          push: ${{ github.event_name == 'push' }} # Solo hacer push en evento 'push'
          tags: ${{ env.INGEST_IMAGE_NAME_BASE }}:${{ steps.image_tag_common.outputs.image_tag }} # Imagen:tag
          cache-from: type=gha # Usar caché de GitHub Actions
          cache-to: type=gha,mode=max # Guardar caché

      # 7. Construir y Empujar Imagen - Query Service (solo si cambió)
      - name: Build and push Query Service Docker image
        id: build_query
        if: steps.changed_files.outputs.query_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.QUERY_SERVICE_DIR }}
          file: ./${{ env.QUERY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.QUERY_IMAGE_NAME_BASE }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 8. Construir y Empujar Imagen - API Gateway (solo si cambió)
      - name: Build and push API Gateway Docker image
        id: build_gateway
        if: steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.GATEWAY_SERVICE_DIR }}
          file: ./${{ env.GATEWAY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.GATEWAY_IMAGE_NAME_BASE }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 2: Actualizar los manifiestos en el repo 'manifests-nyro'
  update-manifests:
    needs: build-push # Depende del job anterior
    runs-on: ubuntu-latest
    # Ejecutar solo si es un evento 'push' Y si AL MENOS UNA imagen fue construida
    if: github.event_name == 'push' && (needs.build-push.outputs.ingest_built == 'true' || needs.build-push.outputs.query_built == 'true' || needs.build-push.outputs.gateway_built == 'true')

    steps:
      # 1. Checkout del repositorio de manifests
      - name: Checkout Manifests Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MANIFEST_REPO_OWNER }}/${{ env.MANIFEST_REPO_NAME }}
          ref: ${{ env.MANIFEST_REPO_BRANCH }}
          # ¡IMPORTANTE! Necesitas un Personal Access Token (Classic) con permiso 'repo' (o 'contents: write')
          # Guárdalo como un secreto en tu repositorio llamado MANIFEST_PAT
          token: ${{ secrets.MANIFEST_PAT }}
          path: manifests-repo # Hacer checkout en un subdirectorio para evitar conflictos

      # 2. Usar el tag común generado en el job anterior
      - name: Set Common Image Tag from previous job
        id: image_tag_common
        run: echo "image_tag=${{ needs.build-push.outputs.image_tag }}" >> $GITHUB_OUTPUT

      # 3. Actualizar archivos de Manifest condicionalmente usando sed
      - name: Update Manifest Files Conditionally
        id: update_manifest
        env:
          # Pasar los outputs del job anterior y el tag
          INGEST_BUILT: ${{ needs.build-push.outputs.ingest_built }}
          QUERY_BUILT: ${{ needs.build-push.outputs.query_built }}
          GATEWAY_BUILT: ${{ needs.build-push.outputs.gateway_built }}
          COMMON_TAG: ${{ steps.image_tag_common.outputs.image_tag }}
          # Pasar las rutas relativas y nombres base de imagen definidos globalmente
          INGEST_API_MANIFEST_PATH: ${{ env.INGEST_API_MANIFEST_PATH_REL }}
          INGEST_WORKER_MANIFEST_PATH: ${{ env.INGEST_WORKER_MANIFEST_PATH_REL }}
          QUERY_MANIFEST_PATH: ${{ env.QUERY_MANIFEST_PATH_REL }}
          GATEWAY_MANIFEST_PATH: ${{ env.GATEWAY_MANIFEST_PATH_REL }}
          INGEST_IMAGE_BASE: ${{ env.INGEST_IMAGE_NAME_BASE }}
          QUERY_IMAGE_BASE: ${{ env.QUERY_IMAGE_NAME_BASE }}
          GATEWAY_IMAGE_BASE: ${{ env.GATEWAY_IMAGE_NAME_BASE }}
        run: |
          echo "::group::Updating Manifest Files Conditionally"
          # Navegar al directorio donde se hizo checkout del repo de manifests
          cd manifests-repo
          echo "Current directory: $(pwd)"
          echo "Ingest Built: $INGEST_BUILT"
          echo "Query Built: $QUERY_BUILT"
          echo "Gateway Built: $GATEWAY_BUILT"
          echo "Common Tag: $COMMON_TAG"
          echo "Ingest API Path: $INGEST_API_MANIFEST_PATH"
          echo "Ingest Worker Path: $INGEST_WORKER_MANIFEST_PATH"
          echo "Query Path: $QUERY_MANIFEST_PATH"
          echo "Gateway Path: $GATEWAY_MANIFEST_PATH"

          MANIFEST_UPDATED=false # Flag para saber si se hizo algún cambio real
          UPDATE_FAILED=false # Flag para saber si hubo algún error

          # --- Función robusta para actualizar la línea 'image:' en un archivo YAML ---
          # Argumentos: $1=ruta_manifest, $2=nombre_imagen_base, $3=nuevo_tag
          update_image_in_manifest() {
            local manifest_path="$1"
            local image_base_name="$2"
            local new_tag="$3"
            local target_image="${image_base_name}:${new_tag}" # Imagen completa con tag

            echo "Attempting to update image in '$manifest_path' for base '$image_base_name' to tag '$new_tag'"

            # Verificar si el archivo existe
            if [ ! -f "$manifest_path" ]; then
              echo "ERROR: Manifest file '$manifest_path' not found! Check env var MANIFEST_PATH_REL."
              UPDATE_FAILED=true
              return 1 # Indicar fallo
            fi

            # Construir el patrón sed:
            # ^                             -> Inicio de línea
            # \s* -> Cero o más espacios (para indentación)
            # image:                        -> Literal 'image:'
            # \s+                           -> Uno o más espacios
            # ${image_base_name//\//\\/}   -> Nombre base de imagen, escapando '/' para sed
            # :                             -> Literal ':'
            # .* -> Cualquier caracter hasta el final (el tag viejo)
            # $                             -> Fin de línea
            local sed_pattern="^\s*image:\s+${image_base_name//\//\\/}:.*$"
            # Reemplazo: mantiene la indentación original encontrada (\1), añade 'image: ', y la nueva imagen:tag
            local sed_replacement="\1image: ${target_image}"

            # Usar sed para reemplazar la línea. -i.bak crea un backup.
            # Usamos 'sed -n' y 'p' para solo imprimir la línea modificada (si existe) y evitar errores si no hay match
            # Luego usamos 'sed -i' real si el patrón fue encontrado.
            if grep -qE "$sed_pattern" "$manifest_path"; then
               echo "Found image line matching pattern in '$manifest_path'. Attempting replacement..."
               # Usar delimitador @ para evitar conflictos con / en la imagen
               if sed -i.bak -E "s@(${sed_pattern})@${sed_replacement}@g" "$manifest_path"; then
                  # Verificar si realmente hubo un cambio comparando con el backup
                  if ! cmp -s "$manifest_path" "$manifest_path.bak"; then
                    echo "Successfully updated image in '$manifest_path' to '$target_image'"
                    MANIFEST_UPDATED=true
                  else
                    echo "Image in '$manifest_path' was already up-to-date with '$target_image'."
                  fi
                  rm -f "$manifest_path.bak" # Limpiar backup si sed fue exitoso
                  return 0 # Indicar éxito
               else
                  echo "ERROR: sed command failed for '$manifest_path'"
                  rm -f "$manifest_path.bak" # Limpiar backup aunque falle
                  UPDATE_FAILED=true
                  return 1 # Indicar fallo
               fi
            else
                echo "WARNING: Pattern '$sed_pattern' not found in '$manifest_path'. Skipping update for this file/image combination."
                # No marcamos como fallo, podría ser intencional (ej. worker no usa imagen)
                return 0 # No es un error fatal no encontrar el patrón
            fi
          }

          # --- Actualizar Ingest Service (API y Worker si aplica) ---
          if [ "$INGEST_BUILT" = "true" ]; then
            update_image_in_manifest "$INGEST_API_MANIFEST_PATH" "$INGEST_IMAGE_BASE" "$COMMON_TAG"
            # Solo intentar actualizar el worker si la ruta está definida y no vacía
            if [ -n "$INGEST_WORKER_MANIFEST_PATH" ]; then
               update_image_in_manifest "$INGEST_WORKER_MANIFEST_PATH" "$INGEST_IMAGE_BASE" "$COMMON_TAG"
            fi
          else
            echo "Skipping Ingest Service manifest update (not built)."
          fi

          # --- Actualizar Query Service ---
          if [ "$QUERY_BUILT" = "true" ]; then
            update_image_in_manifest "$QUERY_MANIFEST_PATH" "$QUERY_IMAGE_BASE" "$COMMON_TAG"
          else
            echo "Skipping Query Service manifest update (not built)."
          fi

          # --- Actualizar API Gateway ---
          if [ "$GATEWAY_BUILT" = "true" ]; then
            update_image_in_manifest "$GATEWAY_MANIFEST_PATH" "$GATEWAY_IMAGE_BASE" "$COMMON_TAG"
          else
            echo "Skipping API Gateway manifest update (not built)."
          fi

          # Exportar si algún manifest fue actualizado REALMENTE
          echo "Final Manifest Updated Status: $MANIFEST_UPDATED"
          echo "manifest_updated=$MANIFEST_UPDATED" >> $GITHUB_OUTPUT

          echo "--- Checking Git Status Before Commit ---"
          git status

          if [ "$UPDATE_FAILED" = "true" ]; then
            echo "::error::One or more manifest updates failed critically (e.g., file not found or sed error). Please check logs."
            exit 1 # Fallar el step si hubo errores críticos
          fi

          echo "::endgroup::"

      # 4. Commit y Push de los Cambios del Manifest (solo si hubo cambios reales y no hubo errores)
      - name: Commit and Push Manifest Changes
        # Ejecutar solo si el step anterior fue exitoso Y si el flag manifest_updated es true
        if: steps.update_manifest.outcome == 'success' && steps.update_manifest.outputs.manifest_updated == 'true'
        run: |
          echo "::group::Committing and Pushing Manifest Changes"
          cd manifests-repo # Ir al directorio del repo de manifests

          # Configurar Git user para el commit
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Añadir todos los cambios (archivos .bak ya fueron borrados)
          git add .

          # Comprobar si hay cambios para commitear (doble chequeo)
          if git diff --staged --quiet; then
            echo "No actual manifest changes staged. Skipping commit."
          else
            echo "Manifest changes detected. Committing..."
            COMMIT_MSG="Update service image(s) to tag ${{ steps.image_tag_common.outputs.image_tag }} [CI]"
            git commit -m "$COMMIT_MSG"
            echo "Pushing changes to origin/${{ env.MANIFEST_REPO_BRANCH }}..."
            # Añadir reintento simple para push en caso de fallo temporal
            git push origin ${{ env.MANIFEST_REPO_BRANCH }} || (sleep 5 && git push origin ${{ env.MANIFEST_REPO_BRANCH }})
            echo "Push successful."
          fi
          echo "::endgroup::"

