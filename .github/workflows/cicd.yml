name: CI/CD Pipeline Docker -> Manifest Update (Ingest & Query)

on:
  push:
    branches: [ "develop" ] # Dispara en push a la rama develop

env:
  # --- Configuración General ---
  REGISTRY: ghcr.io
  MANIFEST_REPO_OWNER: dev-nyro
  MANIFEST_REPO_NAME: manifests-nyro
  MANIFEST_REPO_BRANCH: develop

  # --- Configuración Ingest Service ---
  INGEST_IMAGE_NAME: ghcr.io/dev-nyro/ingest-service
  INGEST_CONTEXT_PATH: ./ingest-service # Path al Dockerfile y código de ingest
  INGEST_MANIFEST_PATH_API: ingest-service/deployment-api.yaml
  INGEST_MANIFEST_PATH_WORKER: ingest-service/deployment-worker.yaml

  # --- Configuración Query Service ---
  QUERY_IMAGE_NAME: ghcr.io/dev-nyro/query-service # Nuevo nombre de imagen
  QUERY_CONTEXT_PATH: ./query-service # Path al Dockerfile y código de query
  QUERY_MANIFEST_PATH: query-service/deployment.yaml # Path al manifest de query

jobs:
  build-push-update:
    runs-on: ubuntu-latest

    permissions:
      contents: read    # Permiso para leer el código fuente
      packages: write   # Permiso para escribir en GitHub Packages (GHCR)

    steps:
      # 1. Checkout del código fuente (ambos microservicios)
      - name: Checkout Application Code
        uses: actions/checkout@v4
        # Fetch all history for accurate short SHA generation if needed (usually not necessary)
        # with:
        #   fetch-depth: 0

      # 2. Configurar Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Login a GitHub Container Registry (GHCR)
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Token automático de GitHub Actions

      # 4. Generar etiqueta común para las imágenes (basada en el commit)
      - name: Generate Common Image Tag
        id: image_tag_common
        run: |
          # Usar ref_name para la rama/tag y hash corto del commit
          TAG="${{ github.ref_name }}-$(echo $GITHUB_SHA | cut -c1-7)"
          # Reemplazar caracteres no válidos para Docker (excepto . y -)
          TAG=$(echo $TAG | sed 's/[^a-zA-Z0-9.-]/-/g')
          # Asegurarse de que no empiece o termine con . o - (simplificado)
          TAG=$(echo $TAG | sed 's/^[.-]*//;s/[.-]*$//')
          echo "Generated Common Tag: $TAG"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # 5. Construir y Empujar Imagen Docker - Ingest Service
      - name: Build and push Ingest Service Docker image
        id: build_ingest
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.INGEST_CONTEXT_PATH }}
          file: ${{ env.INGEST_CONTEXT_PATH }}/Dockerfile
          push: ${{ github.event_name == 'push' }} # Solo empujar en evento 'push'
          tags: ${{ env.INGEST_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Añadido para obtener digest/metadata si se necesita en el futuro
          outputs: type=registry,push=${{ github.event_name == 'push' }}

      # 6. Construir y Empujar Imagen Docker - Query Service
      # !! ESTE PASO FALLARÁ SI poetry.lock NO ESTÁ EN query-service !!
      - name: Build and push Query Service Docker image
        id: build_query
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.QUERY_CONTEXT_PATH }}
          file: ${{ env.QUERY_CONTEXT_PATH }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.QUERY_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Añadido para obtener digest/metadata si se necesita en el futuro
          outputs: type=registry,push=${{ github.event_name == 'push' }}

      # --- Actualización del Repositorio de Manifests ---
      # Solo ejecutar en push a develop Y si los builds fueron exitosos (implícito por defecto)
      - name: Checkout Manifests Repository
        if: github.event_name == 'push'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MANIFEST_REPO_OWNER }}/${{ env.MANIFEST_REPO_NAME }}
          ref: ${{ env.MANIFEST_REPO_BRANCH }}
          token: ${{ secrets.MANIFEST_PAT }} # PAT con permisos de escritura
          path: manifests-repo # Clonar en un subdirectorio

      - name: Update Manifest Files
        if: github.event_name == 'push'
        run: |
          echo "::group::Updating Manifest Files"
          cd manifests-repo
          echo "Current directory: $(pwd)"

          COMMON_TAG="${{ steps.image_tag_common.outputs.image_tag }}"
          INGEST_TARGET_IMAGE="${{ env.INGEST_IMAGE_NAME }}:$COMMON_TAG"
          QUERY_TARGET_IMAGE="${{ env.QUERY_IMAGE_NAME }}:$COMMON_TAG"

          # --- Update Ingest Service Manifests ---
          echo "Updating Ingest Service image to: $INGEST_TARGET_IMAGE"
          INGEST_API_FILE="${{ env.INGEST_MANIFEST_PATH_API }}"
          INGEST_WORKER_FILE="${{ env.INGEST_MANIFEST_PATH_WORKER }}"

          # Usar -i'' en macOS, -i en Linux para sed in-place sin backup
          echo "Updating $INGEST_API_FILE..."
          sed -i "s|image: .*|image: $INGEST_TARGET_IMAGE|" "$INGEST_API_FILE"
          grep 'image:' "$INGEST_API_FILE"

          echo "Updating $INGEST_WORKER_FILE..."
          sed -i "s|image: .*|image: $INGEST_TARGET_IMAGE|" "$INGEST_WORKER_FILE"
          grep 'image:' "$INGEST_WORKER_FILE"

          # --- Update Query Service Manifest ---
          echo "Updating Query Service image to: $QUERY_TARGET_IMAGE"
          QUERY_FILE="${{ env.QUERY_MANIFEST_PATH }}"

          echo "Updating $QUERY_FILE..."
          # Verificar que el archivo existe antes de modificar
          if [ -f "$QUERY_FILE" ]; then
            sed -i "s|image: .*|image: $QUERY_TARGET_IMAGE|" "$QUERY_FILE"
            grep 'image:' "$QUERY_FILE"
          else
            echo "ERROR: Manifest file $QUERY_FILE not found!"
            exit 1
          fi

          echo "--- Checking Git Status ---"
          git status
          echo "::endgroup::"

      - name: Commit and Push Manifest Changes
        if: github.event_name == 'push'
        run: |
          echo "::group::Committing and Pushing Manifest Changes"
          cd manifests-repo
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Añadir todos los archivos modificados en los directorios relevantes
          git add ${{ env.INGEST_MANIFEST_PATH_API }} ${{ env.INGEST_MANIFEST_PATH_WORKER }} ${{ env.QUERY_MANIFEST_PATH }}

          if git diff --staged --quiet; then
            echo "No manifest changes detected. Nothing to commit."
          else
            echo "Manifest changes detected. Committing..."
            COMMIT_MSG="Update ingest & query images to tag ${{ steps.image_tag_common.outputs.image_tag }} [CI]"
            git commit -m "$COMMIT_MSG"
            echo "Pushing changes to origin/${{ env.MANIFEST_REPO_BRANCH }}..."
            # El token PAT ya debería estar configurado por la action checkout
            git push origin ${{ env.MANIFEST_REPO_BRANCH }}
            echo "Push successful."
          fi
          echo "::endgroup::"