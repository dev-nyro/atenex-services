# .github/workflows/cicd.yml
# Nombre del workflow: Construcción selectiva y actualización de manifiestos para Ingest, Query y Gateway
name: CI/CD Pipeline Docker -> Manifest Update (Ingest, Query & Gateway - Selective Build)

# Eventos que disparan el workflow
on:
  push:
    branches: [ "develop" ] # Dispara en push a la rama develop

# Variables de entorno globales
env:
  # --- Configuración General ---
  REGISTRY: ghcr.io                            # Registro de contenedores
  MANIFEST_REPO_OWNER: dev-nyro                # Dueño del repo de manifiestos
  MANIFEST_REPO_NAME: manifests-nyro           # Nombre del repo de manifiestos
  MANIFEST_REPO_BRANCH: develop                # Rama del repo de manifiestos

  # --- Configuración Específica de Servicios ---
  # Directorios y Nombres Base de Imagen (SIN TAG)
  INGEST_SERVICE_DIR: ingest-service
  INGEST_IMAGE_NAME: ghcr.io/dev-nyro/ingest-service
  QUERY_SERVICE_DIR: query-service
  QUERY_IMAGE_NAME: ghcr.io/dev-nyro/query-service
  GATEWAY_SERVICE_DIR: api-gateway             # Directorio del API Gateway
  GATEWAY_IMAGE_NAME: ghcr.io/dev-nyro/api-gateway # Nombre base imagen API Gateway

# Definición de los jobs
jobs:
  # Job 1: Construir y empujar imágenes si hay cambios
  build-push: # Renombrado para claridad
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Para checkout
      packages: write     # Para push a GHCR
      pull-requests: read # Necesario para tj-actions/changed-files en algunos contextos

    # Outputs para el siguiente job
    outputs:
      ingest_built: ${{ steps.build_ingest.outputs.digest != '' && steps.build_ingest.outcome == 'success' }}
      query_built: ${{ steps.build_query.outputs.digest != '' && steps.build_query.outcome == 'success' }}
      gateway_built: ${{ steps.build_gateway.outputs.digest != '' && steps.build_gateway.outcome == 'success' }} # Output para Gateway
      image_tag: ${{ steps.image_tag_common.outputs.image_tag }} # Pasar el tag generado

    steps:
      # 1. Checkout del código fuente
      - name: Checkout Application Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para changed-files

      # 2. Detectar archivos modificados
      - name: Get changed files
        id: changed_files
        uses: tj-actions/changed-files@v44
        with:
          files_yaml: |
            ingest:
              - '${{ env.INGEST_SERVICE_DIR }}/**'
            query:
              - '${{ env.QUERY_SERVICE_DIR }}/**'
            gateway: # Añadido para Gateway
              - '${{ env.GATEWAY_SERVICE_DIR }}/**'

      # 3. Configurar Docker Buildx (Condicional)
      - name: Set up Docker Buildx
        # Condición actualizada para incluir gateway
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/setup-buildx-action@v3

      # 4. Login a GHCR (Condicional)
      - name: Log in to GitHub Container Registry
        # Condición actualizada para incluir gateway
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5. Generar etiqueta común (Condicional)
      - name: Generate Common Image Tag
        # Condición actualizada para incluir gateway
        if: steps.changed_files.outputs.ingest_any_changed == 'true' || steps.changed_files.outputs.query_any_changed == 'true' || steps.changed_files.outputs.gateway_any_changed == 'true'
        id: image_tag_common
        run: |
          # Usando el mismo método de sanitización que en la versión "correcta"
          TAG="${{ github.ref_name }}-$(echo $GITHUB_SHA | cut -c1-7)"
          TAG=$(echo $TAG | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/^[.-]*//;s/[.-]*$//')
          TAG=${TAG::128} # Limitar longitud
          echo "Generated Common Tag: $TAG"
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # 6. Construir y Empujar Imagen Docker - Ingest Service (Condicional)
      - name: Build and push Ingest Service Docker image
        id: build_ingest
        if: steps.changed_files.outputs.ingest_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.INGEST_SERVICE_DIR }}
          file: ./${{ env.INGEST_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.INGEST_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry,push=${{ github.event_name == 'push' }} # Asegura que el digest se genere

      # 7. Construir y Empujar Imagen Docker - Query Service (Condicional)
      - name: Build and push Query Service Docker image
        id: build_query
        if: steps.changed_files.outputs.query_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.QUERY_SERVICE_DIR }}
          file: ./${{ env.QUERY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.QUERY_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry,push=${{ github.event_name == 'push' }} # Asegura que el digest se genere

      # 8. Construir y Empujar Imagen Docker - API Gateway (Condicional) - ¡NUEVO!
      - name: Build and push API Gateway Docker image
        id: build_gateway
        if: steps.changed_files.outputs.gateway_any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.GATEWAY_SERVICE_DIR }}
          file: ./${{ env.GATEWAY_SERVICE_DIR }}/Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ env.GATEWAY_IMAGE_NAME }}:${{ steps.image_tag_common.outputs.image_tag }} # Usa variables de Gateway
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=registry,push=${{ github.event_name == 'push' }} # Asegura que el digest se genere

  # --- Job separado para actualizar manifests ---
  update-manifests:
    needs: build-push # Depende del job anterior renombrado
    runs-on: ubuntu-latest
    # Condición actualizada para incluir gateway_built
    if: github.event_name == 'push' && (needs.build-push.outputs.ingest_built == 'true' || needs.build-push.outputs.query_built == 'true' || needs.build-push.outputs.gateway_built == 'true')

    steps:
      # 1. Checkout del repositorio de manifests
      - name: Checkout Manifests Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MANIFEST_REPO_OWNER }}/${{ env.MANIFEST_REPO_NAME }}
          ref: ${{ env.MANIFEST_REPO_BRANCH }}
          token: ${{ secrets.MANIFEST_PAT }} # Asegúrate que este PAT tenga permisos de escritura
          path: manifests-repo

      # 2. Usar el tag común generado en el job anterior (¡NO REGENERAR!)
      #    Se pasa como env var al siguiente paso.

      # 3. Actualizar archivos de Manifest (Condicionalmente dentro del script)
      - name: Update Manifest Files Conditionally
        id: update_manifest # ID del step mantenido
        env:
          # Pasar outputs del job anterior
          INGEST_BUILT: ${{ needs.build-push.outputs.ingest_built }}
          QUERY_BUILT: ${{ needs.build-push.outputs.query_built }}
          GATEWAY_BUILT: ${{ needs.build-push.outputs.gateway_built }} # Añadido para Gateway
          COMMON_TAG: ${{ needs.build-push.outputs.image_tag }} # Obtenido del job anterior
          # Construir los paths relativos aquí usando las variables base
          INGEST_MANIFEST_PATH_API_REL: ${{ env.INGEST_SERVICE_DIR }}/deployment-api.yaml
          INGEST_MANIFEST_PATH_WORKER_REL: ${{ env.INGEST_SERVICE_DIR }}/deployment-worker.yaml
          QUERY_MANIFEST_PATH_REL: ${{ env.QUERY_SERVICE_DIR }}/deployment.yaml
          GATEWAY_MANIFEST_PATH_REL: ${{ env.GATEWAY_SERVICE_DIR }}/deployment.yaml # Añadido para Gateway
        run: |
          echo "::group::Updating Manifest Files Conditionally"
          cd manifests-repo
          echo "Current directory: $(pwd)"
          echo "Ingest Built: $INGEST_BUILT"
          echo "Query Built: $QUERY_BUILT"
          echo "Gateway Built: $GATEWAY_BUILT" # Log añadido
          echo "Common Tag: $COMMON_TAG"
          echo "Ingest API Path: $INGEST_MANIFEST_PATH_API_REL"
          echo "Ingest Worker Path: $INGEST_MANIFEST_PATH_WORKER_REL"
          echo "Query Path: $QUERY_MANIFEST_PATH_REL"
          echo "Gateway Path: $GATEWAY_MANIFEST_PATH_REL" # Log añadido

          MANIFEST_UPDATED=false # Flag para saber si algo cambió

          # --- Update Ingest Service ---
          if [ "$INGEST_BUILT" = "true" ]; then
            # Usar el nombre base de la imagen definido en env global
            INGEST_TARGET_IMAGE="${{ env.INGEST_IMAGE_NAME }}:$COMMON_TAG"
            echo "Attempting to update Ingest Service image to: $INGEST_TARGET_IMAGE in relevant files..."

            # Actualizar API manifest
            if [ -f "$INGEST_MANIFEST_PATH_API_REL" ]; then
              # Usando el sed simple de la versión "correcta"
              sed -i "s|image: .*|image: $INGEST_TARGET_IMAGE|" "$INGEST_MANIFEST_PATH_API_REL"
              echo "Updated $INGEST_MANIFEST_PATH_API_REL"
              MANIFEST_UPDATED=true
            else
              echo "WARNING: Ingest API manifest '$INGEST_MANIFEST_PATH_API_REL' not found!"
            fi
            # Actualizar Worker manifest (si existe el path)
            if [ -n "$INGEST_MANIFEST_PATH_WORKER_REL" ] && [ -f "$INGEST_MANIFEST_PATH_WORKER_REL" ]; then
              sed -i "s|image: .*|image: $INGEST_TARGET_IMAGE|" "$INGEST_MANIFEST_PATH_WORKER_REL"
              echo "Updated $INGEST_MANIFEST_PATH_WORKER_REL"
              MANIFEST_UPDATED=true
            elif [ -n "$INGEST_MANIFEST_PATH_WORKER_REL" ]; then
               echo "WARNING: Ingest Worker manifest '$INGEST_MANIFEST_PATH_WORKER_REL' provided but not found!"
            fi
          else
            echo "Skipping Ingest Service manifest update (not built)."
          fi

          # --- Update Query Service ---
          if [ "$QUERY_BUILT" = "true" ]; then
            # Usar el nombre base de la imagen definido en env global
            QUERY_TARGET_IMAGE="${{ env.QUERY_IMAGE_NAME }}:$COMMON_TAG"
            echo "Attempting to update Query Service image to: $QUERY_TARGET_IMAGE in $QUERY_MANIFEST_PATH_REL"

            if [ -f "$QUERY_MANIFEST_PATH_REL" ]; then
              # Usando el sed simple de la versión "correcta"
              sed -i "s|image: .*|image: $QUERY_TARGET_IMAGE|" "$QUERY_MANIFEST_PATH_REL"
              echo "Updated $QUERY_MANIFEST_PATH_REL"
              MANIFEST_UPDATED=true
            else
              # Considerar esto un error si el servicio se construyó pero el manifest no existe
              echo "::error::Query manifest file '$QUERY_MANIFEST_PATH_REL' not found!"
              exit 1 # Fallar el script si el manifest principal no se encuentra
            fi
          else
            echo "Skipping Query Service manifest update (not built)."
          fi

          # --- Update API Gateway --- ¡NUEVO BLOQUE!
          if [ "$GATEWAY_BUILT" = "true" ]; then
            # Usar el nombre base de la imagen definido en env global
            GATEWAY_TARGET_IMAGE="${{ env.GATEWAY_IMAGE_NAME }}:$COMMON_TAG"
            echo "Attempting to update API Gateway image to: $GATEWAY_TARGET_IMAGE in $GATEWAY_MANIFEST_PATH_REL"

            # Usar la variable _REL que ahora tiene el path correcto
            if [ -f "$GATEWAY_MANIFEST_PATH_REL" ]; then
              # Usando el sed simple de la versión "correcta"
              sed -i "s|image: .*|image: $GATEWAY_TARGET_IMAGE|" "$GATEWAY_MANIFEST_PATH_REL"
              echo "Updated $GATEWAY_MANIFEST_PATH_REL"
              MANIFEST_UPDATED=true
            else
              # Considerar esto un error si el servicio se construyó pero el manifest no existe
              echo "::error::API Gateway manifest file '$GATEWAY_MANIFEST_PATH_REL' not found!"
              exit 1 # Fallar el script si el manifest principal no se encuentra
            fi
          else
            echo "Skipping API Gateway manifest update (not built)."
          fi

          # Exportar si hubo algún cambio
          echo "manifest_updated=$MANIFEST_UPDATED" >> $GITHUB_OUTPUT
          echo "--- Checking Git Status Before Commit ---"
          git status
          echo "::endgroup::"

      # 4. Commit y Push de los Cambios del Manifest (si hubo cambios)
      - name: Commit and Push Manifest Changes
        # Condición basada en el output del script anterior
        if: steps.update_manifest.outputs.manifest_updated == 'true'
        run: |
          echo "::group::Committing and Pushing Manifest Changes"
          cd manifests-repo
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Añadir todos los cambios detectados por git
          git add .

          # Verificar si hay cambios preparados (staged) antes de hacer commit
          if git diff --staged --quiet; then
            echo "No actual changes staged by 'git add .'. This might indicate the sed command didn't modify files as expected or files were already correct. Skipping commit."
          else
            echo "Manifest changes detected and staged. Committing..."
            # Usar el tag obtenido del job anterior via env var
            COMMIT_MSG="Update service image(s) to tag ${{ env.COMMON_TAG }} [CI]"
            git commit -m "$COMMIT_MSG"
            echo "Pushing changes to origin/${{ env.MANIFEST_REPO_BRANCH }}..."
            # Usando el push simple de la versión "correcta" (sin retry)
            if git push origin ${{ env.MANIFEST_REPO_BRANCH }}; then
               echo "Push successful."
            else
               echo "::error::Push failed. Check PAT permissions and branch protection rules."
               exit 1 # Fallar si el push no funciona
            fi
          fi
          echo "::endgroup::"

